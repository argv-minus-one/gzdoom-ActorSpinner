struct ActorSpinner play {
	/** The actor being spun. */
	Actor mo;
	
	/** Current angular velocity of the object, in degrees per tic. */
	float Vel;
	
	/** Desired angular velocity. As long as Vel != DesVel, Vel will increase/decrease every tic (by Accel/Decel) until it reaches DesVel. */
	float DesVel;
	
	/** When accelerating, this is how much Vel in/decreases per tic. */
	float Accel;
	
	/** If not zero, acceleration will be at this rate until Vel reaches DesVel. */
	private float TmpAccel;
	private int TmpAccelTime;
	
	/** If TmpAccel is in use, then when Vel reaches DesVel, rotation will snap to this angle (if possible). */
	private float SnapAngle;
	
	/** Resets the state of this ActorSpinner. The fields mo, DesVel, Accel, and Decel are not affected. */
	void Reset() {
		Vel = TmpAccel = 0;
	}
	
	void Tick() {
		if (!mo) {
			Console.Printf("\cgActorSpinner.Tick called, but mo (the actor to be rotated) is null!");
			return;
		}
		
		if (TmpAccel != 0.) {
			if (((Vel >= DesVel) != (Vel + TmpAccel >= DesVel)) || (TmpAccelTime == 0)) {
				// Reached DesVel while TmpAccel is active.
				// Try to snap to SnapAngle. If impossible, get as close as possible.
				
				// This is the range of achievable angular velocities on this tic. X is in the negative direction, Y is in the positive direction.
				let allowedVel = (Vel - Accel, Vel + Accel);
				// This is the range of achievable roll angles on this tic.
				let allowedRoll = (mo.Roll + allowedVel.X, mo.Roll + allowedVel.Y);
				
				// Apply acceleration and rotation.
				Vel = clamp(DesVel, allowedVel.X, allowedVel.Y);
				mo.Roll = clamp(SnapAngle, allowedRoll.X, allowedRoll.Y);
				
				// TmpAccel mode complete.
				TmpAccel = 0;
			}
			else {
				// Apply acceleration and rotation according to TmpAccel.
				Vel += TmpAccel;
				TmpAccelTime--;
				mo.Roll = Actor.Normalize180(mo.Roll + Vel);
			}
		}
		else {
			// Apply acceleration.
			if (DesVel > Vel)
				Vel = min(Vel + Accel, DesVel);
			else
				Vel = max(Vel - Accel, DesVel);
			
			// Apply rotation.
			mo.Roll = Actor.Normalize180(mo.Roll + Vel);
		}
	}
	
	/**
	 * Accelerate or decelerate the object such that, after enough rotations, its angular velocity will equal DesVel when its roll crosses the angle desiredRoll. Be sure to set DesVel *before* calling this method.
	 *
	 * After this method is called, this ActorSpinner will enter landing mode. Do not change the DesVel field while this mode is active; that will make the animation behave strangely. The IsLandingInProgress method returns true if this mode is active. Call CancelLanding to cancel this mode and resume normal operation. Changing DesVel and immediately calling this method again is also safe.
	 *
	 * The main use case of this method is to make the object spin down such that, when it stops spinning, it ends up at the desired roll angle (typically zero).
	 */
	void LandAt(float desiredRoll) {
		SnapAngle = desiredRoll;
		
		if (desiredRoll < mo.Roll)
			desiredRoll += 360;
		
		let avel = abs(Vel);
		int spinCount = 1 + ceil((avel * avel / Accel - 2 * (desiredRoll - mo.Roll) - 1.) / 2 * 360.);
		float adjustedRoll = desiredRoll + spinCount * 360. + avel / 2;
		float degLeft = desiredRoll - mo.Roll;
		TmpAccelTime = ceil(2 * degLeft / avel + 1.);
		TmpAccel = avel * avel / (2 * degLeft + 1.);
		if (Vel > 0.)
			TmpAccel = -TmpAccel;
	}
	
	/** Cancels the effect of a previous call to LandAt. */
	void CancelLanding() {
		TmpAccel = 0;
	}
	
	/** Returns true if this ActorSpinner is still in landing mode. */
	bool IsLandingInProgress() const {
		return TmpAccel != 0.;
	}
}
