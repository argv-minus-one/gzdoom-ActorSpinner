struct INIFile {
	// Bit mask for which of the 32 first ASCII characters is whitespace.
	// ASCII 32 (space) doesn't fit into a 32-bit integer, so it's handled separately.
	const WhitespaceASCIIChars = 15872;
	
	static String TrimSpace(String s, bool fromStart = true, bool fromEnd = true) {
		let len = s.Length();
		if (len == 0)
			return "";
		
		int start = 0, end = max(len - 1, 0);
		
		// Find first non-whitespace character.
		if (fromStart)
		for (let i = 0; i < len; i++) {
			let code = s.CharCodeAt(i);
			if (
				code == 32 ||
				(code <= 31 && ((1 << code) & WhitespaceASCIIChars))
			)
				start = i + 1;
			else
				break;
		}
		
		// Find last non-whitespace character.
		if (fromEnd)
		for (let i = end; i > start; i--) {
			let code = s.CharCodeAt(i);
			if (
				code == 32 ||
				(code <= 31 && ((1 << code) & WhitespaceASCIIChars))
			)
				end = i - 1;
			else
				break;
		}
		
		if (start > end)
			return "";
		else
			return s.Mid(start, (end - start) + 1);
	}
	
	static bool IsAllSpace(String s) {
		for (let i = 0, len = s.Length(); i < len; i++) {
			let code = s.CharCodeAt(i);
			if (
				code != 32 &&
				(code > 31 || !((1 << code) & WhitespaceASCIIChars))
			)
				return false;
		}
		
		return true;
	}
	
	Array<INISection> Sections;
	
	void Clear() {
		Sections.Clear();
	}
	
	void Read(int lump, bool sectionIgnoreCase = false, bool keyIgnoreCase = false) {
		let text = Wads.ReadLump(lump);
		Array<String> lines;
		text.Split(lines, "\n", TOK_SKIPEMPTY);
		INISection curSection = null;
		uint curKey = uint.max;
		
		for (uint lineNum = 0, lineCount = lines.Size(); lineNum < lineCount; lineNum++) {
			let line = TrimSpace(lines[lineNum]);
			
			// Skip blank lines and comment lines.
			if (line == "" || line.CharAt(0) == "#")
				continue;
			
			if (line.CharAt(0) == "[") {
				// This is a section header.
				let end = line.IndexOf("]", 1);
				
				if (end < 0) {
					Console.Printf("\cgLump %d line %d: Section header does not contain a ']' character.", lump, lineNum);
					end = line.Length();
				}
				else if (end != line.Length() - 1) {
					Console.Printf("\cgLump %d line %d: Ignoring garbage text after end of section header: %s", lump, lineNum, line.Mid(end + 1));
				}
				
				let sectionName = line.Mid(1, end - 1);
				
				curSection = NewSection(sectionName, ignoreCase: sectionIgnoreCase);
				curKey = uint.max;
			}
			else {
				if (!curSection) {
					// No section for this key, so make a special blank section for it.
					curSection = NewSection("");
				}
				
				let equalSign = line.IndexOf("=");
				
				if (equalSign >= 0) {
					// This is a key=value line.
					let key = TrimSpace(line.Left(equalSign), fromStart: false);
					let value = TrimSpace(line.Mid(equalSign + 1), fromEnd: false);
					String oldValue;
					[oldValue, curKey] = curSection.Set(key, value, keyIgnoreCase: keyIgnoreCase);
				}
				else if (curKey != uint.max) {
					// This is a continuation line. Append its contents to the value of the current key.
					curSection.Values[curKey] = curSection.Values[curKey] .. (curSection.Values[curKey] == ""? "" : "\n") .. line;
				}
				else {
					// This is garbage.
					Console.Printf("\cgLump %d line %d: Ignoring garbage text: %s", lump, lineNum, line);
				}
			}
		}
	}
	
	void ReadLumpsNamed(String lumpName, int ns = Wads.GlobalNamespace, bool sectionIgnoreCase = false, bool keyIgnoreCase = false) {
		for (let lump = Wads.FindLump(lumpName, ns: ns); lump >= 0; lump = Wads.FindLump(lumpName, lump + 1, ns: ns))
			Read(lump, sectionIgnoreCase: sectionIgnoreCase, keyIgnoreCase: keyIgnoreCase);
	}
	
	INISection NewSection(String name, bool ignoreCase = false) {
		let s = Section(name, ignoreCase: ignoreCase);
		if (!s) {
			s = new("INISection");
			s.Name = name;
			Sections.Push(s);
		}
		return s;
	}
	
	INISection, uint Section(String sectionName, bool ignoreCase = false) const {
		uint i, s;
		for (i = 0, s = Sections.Size(); i < s; i++) {
			let section = Sections[i];
			if (!section)
				continue;
			let foundName = section.name;
			if (ignoreCase? foundName ~== sectionName : foundName == sectionName)
				return section, i;
		}
		
		return null, i;
	}
	
	INISection CurrentMapSection() const {
		return Section(level.MapName, ignoreCase: true);
	}
	
	String, INISection, uint Get(String sectionName, String key, bool sectionIgnoreCase = false, bool keyIgnoreCase = false) const {
		let section = Section(sectionName, ignoreCase: sectionIgnoreCase);
		if (!section)
			return "", null, 0;
		
		String value;
		uint keyIndex;
		[value, keyIndex] = section.Get(key);
		
		return value, section, keyIndex;
	}
	
	String, INISection, uint CurrentMapGet(String key, bool ignoreCase = false) const {
		return Get(level.MapName, key, sectionIgnoreCase: true, keyIgnoreCase: ignoreCase);
	}
	
	String, INISection, uint Set(String sectionName, String key, String value, bool sectionIgnoreCase = false, bool keyIgnoreCase = false) {
		let section = NewSection(sectionName);
		String oldValue;
		uint keyIndex;
		[oldValue, keyIndex] = section.Set(key, value);
		return oldValue, section, keyIndex;
	}
	
	void DumpToConsole() const {
		for (uint sec = 0, secs = Sections.Size(); sec < secs; sec++) {
			let so = Sections[sec];
			Console.Printf("[%s]", so.Name);
			
			for (uint key = 0, keys = so.Keys.Size(); key < keys; key++)
				Console.Printf("%s=%s", so.Keys[key], so.Values[key]);
		}
	}
	
	/**
	 * Scan all loaded actor classes, and merge together keys in the corresponding INI sections.
	 *
	 * Section names ending with + apply to that class and all subclasses.  
	 * Section names ending with - apply to that class and all superclasses.
	 *
	 * The result will be that all keys in + or - sections appear in the corresponding exact-match sections.
	 *
	 * @param purgeSuperSubSections If true, + and - sections will be removed after merging.
	 * @param purgeNoMatch If true, sections matching no known class will be removed after merging.
	 */
	void MergeByActorClass(bool purgeSuperSubSections = false, bool purgeNoMatch = false, bool keyIgnoreCase = false) {
		for (uint classIndex = 0, classCount = AllActorClasses.Size(); classIndex < classCount; classIndex++) {
			Class<Object> subjClass = AllActorClasses[classIndex];
			let subjName = subjClass.GetClassName();
			let subjSection = Section(subjName, ignoreCase: true);
			let superSection = Section(subjName .. "-", ignoreCase: true);
			
			// Walk up the list of superclasses.
			for (let parClass = subjClass; parClass; parClass = parClass.GetParentClass()) {
				let parName = parClass.GetClassName();
				
				// Merge in its + section, if any.
				let parSubSection = Section(parName .. "+", ignoreCase: true);
				if (parSubSection) {
					if (!subjSection)
						subjSection = NewSection(subjName, ignoreCase: true);
					subjSection.Merge(parSubSection);
				}
				
				// Merge in this class' - section, if any.
				if (superSection) {
					let parSection = NewSection(parName, ignoreCase: true);
					parSection.Merge(superSection);
				}
				
				// Stop at Actor, ignoring its superclasses.
				// The only reason we do this is because there is no global list of non-actor classesâ€¦
				if (parClass == 'Actor')
					break;
			}
		}
		
		if (purgeNoMatch || purgeSuperSubSections)
		for (uint sectionIndex = Sections.Size() - 1; sectionIndex >= 0; sectionIndex--) {
			let sectionName = Sections[sectionIndex].Name;
			let nameLen = sectionName.Length();
			
			if (nameLen >= 2)
			switch (sectionName.CharCodeAt(nameLen - 1)) {
				case 43: // +
				case 45: // -
					if (purgeSuperSubSections) {
						Sections.Delete(sectionIndex);
						continue;
					}
					
					sectionName = sectionName.Left(nameLen - 1);
			}
			
			Class<Actor> sectionClass = sectionName;
			if (!sectionClass)
				Sections.Delete(sectionIndex);
		}
	}
}

class INISection {
	String Name;
	Array<String> Keys, Values;
	
	uint IndexOf(String key, bool ignoreCase = false) const {
		if (!ignoreCase || key == "")
			return Keys.Find(key);
		else {
			uint idx, size;
			for (idx = 0, size = Keys.Size(); idx < size; idx++)
			if (Keys[idx] ~== key)
				break;
			return idx;
		}
	}
	
	String, uint Get(String key, bool ignoreCase = false) const {
		let idx = IndexOf(key, ignoreCase: ignoreCase);
		return (idx == Values.Size()? "" : Values[idx]), idx;
	}
	
	String, uint CurrentMapGet() const {
		return Get(level.MapName, ignoreCase: true);
	}
	
	String, uint Set(String key, String value, bool keyIgnoreCase = false) {
		let idx = IndexOf(key, ignoreCase: keyIgnoreCase), ov = "";
		
		if (idx != Values.Size()) {
			ov = Values[idx];
			Values[idx] = value;
		}
		else {
			Keys.Push(key);
			Values.Push(value);
		}
		
		return ov, idx;
	}
	
	String Remove(String key, bool ignoreCase = false) {
		let idx = IndexOf(key, ignoreCase: ignoreCase), ov = "";
		
		if (idx < Keys.Size()) {
			ov = Values[idx];
			Keys.Delete(idx);
			Values.Delete(idx);
		}
		
		return ov;
	}
	
	void Merge(INISection other, bool keepExisting = true, bool keyIgnoreCase = false) {
		for (uint otherIndex = 0, otherSize = other.Keys.Size(); otherIndex < otherSize; otherIndex++) {
			let myIndex = IndexOf(other.Keys[otherIndex], ignoreCase: keyIgnoreCase);
			
			if (myIndex == Keys.Size()) {
				Keys.Push(other.Keys[otherIndex]);
				Values.Push(other.Values[otherIndex]);
			}
			else if (!keepExisting)
				Values[myIndex] = other.Values[otherIndex];
		}
	}
}
